'''

对于一个给定的正整数组成的数组 a[] ，如果将 a 倒序后数字的排列与 a 完全相同，我们称这个数组为“回文”的。
例如， [1, 2, 3, 2, 1] 的倒序是他自己，所以是一个回文的数组；而 [1, 2, 3, 1, 2] 的倒序是 [2, 1, 3, 2, 1] ，所以不是一个回文的数组。
对于任意一个正整数数组，如果我们向其中某些特定的位置插入一些正整数，那么我们总是能构造出一个回文的数组。

输入一个正整数组成的数组，要求你插入一些数字，使其变为回文的数组，且数组中所有数字的和尽可能小。输出这个插入后数组中元素的和。

例如，对于数组 [1, 2, 3, 1, 2] 我们可以插入两个 1 将其变为回文的数组 [1, 2, 1, 3, 1, 2, 1] ，这种变换方式数组的总和最小，为 11 ，所以输出为 11 。


dp[i][j]   :i 从头开始   j从尾开始   dp为最大和

初始状态：dp[0][0] = 0
        dp[i][i] = a[i]

状态转移方程：
        dp[i][j] = min(dp[i+1][j]+2a[i],dp[i][j-1]+2a[j])
        理解：                1 3 2
                               3                    3
                            1     【】    或    【】      2
                          【】      2           1       【】
                dp[0][2] = dp[0][1]+2a[2] 和dp[1][2]+2a[0] 比较
                dp[0][1]为1 3 1
                dp[1][2]为2 3 2
'''


def sum_reverse(string):
    if string == []:
        return 0
    n = len(string)
    dp = [[0]*len(string) for i in range(len(string))]
    for i in range(n):
        dp[i][i] = string[i]


    for i in range(n-2,-1,-1):
        for j in range(i+1,n):
            if string[i] == string[j]:
                dp[i][j] = dp[i+1][j-1] + 2* string[i]
            else:
                dp[i][j] = min(dp[i+1][j]+2*string[i],dp[i][j-1]+2*string[j])
    print(dp)
    return dp[0][n-1]


if __name__ == '__main__':
    string1 = [1,2,3,1,2]
    string = [70, 51, 34, 13, 19, 64 ,31, 21 ,89, 69 ,79 ,48 ,1 ,78, 47 ,94, 74 ,33, 59, 37 ,12 ,7 ,52 ,58 ,45 ,3 ,56 ,42 ,56 ,3 ,45 ,
              58 ,52 ,7 ,12 ,37 ,59 ,33 ,74, 94 ,47 ,78 ,1 ,48, 79, 69 ,89, 21, 31, 64 ,19, 13 ,34, 51, 70]
    print(sum_reverse(string))