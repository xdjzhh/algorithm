'''

某个工厂生产一种产品，有两种装配线选择，每条装配线都有n个装配站。可以单独用，装配线1或2加工生产，也可以使用装配线i的第j个装配站后，进入另一个装配线的第j+1个装配站继续生产。现想找出通过工厂装配线的最快方法。

装配线i的第j个装配站表示为Si,j
,在该站的装配时间是ai,j

如果从 Si,j
装配站生产后，转移到另一个生产线继续生产所耗费的时间为ti,j，ti,j只存在于装配线更换的时候

进入装配线花费时间ei,完成生产后离开装配线所耗费时间为xi

dp[i][j] 最短时间， i： 生产线   j：  装配站

初始状态：
    dp[0][0] = e[0] + a[0][0]
    dp[i][0] = e[i] + a[i][0]

状态转移方程：
    dp[i][j] = min(dp[i][j-1] + a[i][j], dp[k][j-1] + t[k][j-1] + a[i][j])  此时设k为非i的所有值。
    如果只有 0 1 装配线 ，那么方程为：
    dp[0][j] = min(dp[0][j-1] + a[0][j], dp[1][j-1] + t[1][j-1] + a[0][j])

'''

def schedule(e,a,t,x):
    dp = [[0]*len(a[0]) for i in range(2)]

    dp[0][0] = e[0] + a[0][0]
    dp[1][0] = e[1] + a[1][0]
    print(dp[0][0],dp[1][0])
    for j in range(1,len(a[0])):
        dp[0][j] = min(dp[0][j-1]+ a[0][j],dp[1][j-1] + t[1][j-1] + a[0][j])
        # print(dp[1][j-1] , t[0][j-1] , a[0][j])
        dp[1][j] = min(dp[1][j - 1] + a[1][j], dp[0][j - 1] + t[0][j - 1] + a[1][j])
        print(dp[0][j],dp[1][j])
    result0 = dp[0][-1] + x[0]


    # for j in range(1,len(a[1])):
    #     dp[1][j] = min(dp[1][j-1]+ a[1][j],dp[0][j-1] + t[1][j-1] + a[1][j])

    result1 = dp[1][-1] + x[1]
    return min(result0,result1)


if __name__ == '__main__':
    a= [[7, 9, 3, 4, 8, 4],
        [8, 5, 6, 4, 5, 7]]

    t = [[2, 3, 1, 3, 4],
        [2, 1, 2, 2, 1]]

    x = [3, 2]

    e = [2, 4]

    print(schedule(e,a,t,x))